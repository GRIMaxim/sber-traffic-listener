# Traffic listner

## Содержание:
- [Текущие проблемы проекта](#problems)
- [Возможное развитие проекта](#future)
- [Краткое описание](#entry)
- [Перед началом работы](#before-start)
- [Запуск](#start)
    - [Docker](#start-docker)
    - [Локальный запуск](#start-local)

## <p id="problems"> Текущие проблемы проекта </p>

- В текущей реализации параметры get-запроса /visited_links привязаны
  к параметру времени (количество секунд, прошедших
  с начала эпохи), при этом текущее количество
  неизвестно пользователю, но возможно этот сервис
  будет использоваться сторонним API и тогда этот вопрос решен;
- Необходимо обрабатывать post-запрос в фоне и заменить код ответа на <Accepted 202>. 
Background task или create_task частично решит проблему, но лучше использовать celery;
- В проекте присутвуют лишние модули (напр. src.crud.CRUDBase), 
предназначенные для дальнейшего дополнения и развития проекта;
- В качестве ответа на ошибки передается поле status в теле ответа, но 
на мой взгляд лучше передавать status_code 4xx и использовать HTTPException,
а лучше дочерний класс;
- Для изменения базы данных на каждый SQL-запрос выделяется сессия, что 
не является проблемой для текущей реализации, но может стать проблемой при
увеличении числа таблиц и зависимостей.
- Для использования базы данных используется singleton link_db, но 
лучше заменить его на, возможно, класс с сборкой всех зависимых таблиц и 
выделением сессии на их изменение. 

## <p id="future"> Возможное развитие проекта </p>

- Добавление nginx и его настройка для отправки запросов и приемов ответов, а также трансляции 
запросов внутрь контейнера с приложением
- Добавление в приложение таблицы с пользователями, где будет фиксироваться, как минимум, ip-адрес устройства. 
Таким образом будет две связанные таблицы: user - link, в таблице link заменить pk на fk.
- Добавление обработки входящих запросов приложением
- Добавление вывода информации о посещенных конкретным пользователем ссылок и доменов.
- Сбор метрик (напр. prometheus), вывод метрик (напр. grafana)
- Развертка приложения на сервере и использование его в качестве прокси для конечных устройств. 

## <p id="entry"> Краткое описание </p>
### Задание
Реализовать веб-сервис для простого учета посещенных ссылок
### Используемые технологии
- Разработка
  - python
  - fastapi 
  - sqlalchemy  
  - python-dotenv  
  - pydantic 
- Проверки по коду
  - ruff 
  - mypy 
  - deptry 
- Тестирование
  - pytest 
  - coverage
  - pytest-asyncio 
  - httpx 
  - faker 
- Развертка
  - alembic 
  - uvicorn 
  - asyncpg 
### Итоги
- Реализован обработчик post-запросов, принимающий и добавляющий ссылки в базу данных.
- Реализован обработчик get-запросов, возвращающий уникальный список доменов из базы данных.
- Проведена работа над документацией. Доступна по пути /docs (или /redoc)
- Написаны тесты для обработчиков и методов для работы с базой данных
- Покрытие тестами согласно coverage - 98%

## <p id="before-start"> Перед началом работы </p>

Скопируйте проект:

```shell
git clone https://github.com/GRIMaxim/sber-traffic-listener.git
```

## <p id="start"> Запуск </p>

### <p id="start-docker"> Docker </p>

Если присутствуют необходимые компоненты Docker, выполните команду:

```shell
docker-compose up -d --build
```

### <p id="start-local"> Локальный запуск </p>

1) Установите параметры в файле .env проекта:

```dotenv
# используется во время тестирования
F_TEST=false

# пользователь для базы данных
PG_USER=user
# пароль пользователя
PG_PASS=pass
# порт базы данных
PG_PORT=5432
# название базы данных
PG_DATABASE=container_db
```

2) Создайте указанную в параметрах .env базу данных
   PostgreSQL с названием PG_DATABASE и
   пользователя (PG_USER, PG_PASS), если их нет.

3) Установите poetry:

```shell
pip install poetry==1.6.1
```

4) Установите необходимые зависимости (зависимости
   поделены на группы dep, tests, code.
   Для запуска приложения достаточно группы dep):

```shell
poetry install
```

5) Подключитесь к оболочке poetry:

```shell
poetry shell
```

6) Запустите миграции:

```shell
alembic upgrade head
```

7) Запустите приложение:

```shell
uvicorn src.main:main_app --host=localhost --port=8099
```
